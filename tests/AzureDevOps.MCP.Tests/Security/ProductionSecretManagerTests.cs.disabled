using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using System.Collections.Frozen;
using Azure;
using Azure.Security.KeyVault.Secrets;
using AzureDevOps.MCP.Configuration;
using AzureDevOps.MCP.Security;

namespace AzureDevOps.MCP.Tests.Security;

[TestClass]
public class ProductionSecretManagerTests
{
    private Mock<ILogger<ProductionSecretManager>> _mockLogger = null!;
    private Mock<SecretClient> _mockKeyVaultClient = null!;
    private Mock<IOptions<ProductionConfiguration>> _mockOptions = null!;
    private ProductionSecretManager _secretManager = null!;
    private ProductionConfiguration _config = null!;

    [TestInitialize]
    public void Setup()
    {
        _mockLogger = new Mock<ILogger<ProductionSecretManager>>();
        _mockKeyVaultClient = new Mock<SecretClient>();
        _mockOptions = new Mock<IOptions<ProductionConfiguration>>();
        
        _config = new ProductionConfiguration
        {
            Security = new ProductionSecurityConfiguration
            {
                EnableKeyVault = true,
                KeyVaultUrl = "https://test-kv.vault.azure.net/",
                ManagedIdentityClientId = "test-client-id"
            }
        };
        
        _mockOptions.Setup(x => x.Value).Returns(_config);
        _secretManager = new ProductionSecretManager(_mockLogger.Object, _mockOptions.Object);
    }

    [TestCleanup]
    public void Cleanup()
    {
        _secretManager?.Dispose();
    }

    [TestMethod]
    public async Task GetSecretAsync_WhenKeyVaultEnabledAndSecretExists_ReturnsSecret()
    {
        // Arrange
        const string secretName = "TestSecret";
        const string secretValue = "secret-value-123";
        
        var keyVaultSecret = SecretModelFactory.KeyVaultSecret(
            new SecretProperties(secretName), 
            secretValue);
        
        var response = Response.FromValue(keyVaultSecret, Mock.Of<Response>());
        
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()))
            .ReturnsAsync(response);
        

        // Act
        var result = await _secretManager.GetSecretAsync(secretName, CancellationToken.None);

        // Assert
        Assert.AreEqual(secretValue, result);
        _mockKeyVaultClient.Verify(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()), Times.Once);
    }

    [TestMethod]
    public async Task GetSecretAsync_WhenKeyVaultFailsButEnvironmentExists_ReturnsFallback()
    {
        // Arrange
        const string secretName = "TestSecret";
        const string secretValue = "env-secret-value";
        
        Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", secretValue);
        
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new RequestFailedException("Key Vault unreachable"));
        

        try
        {
            // Act
            var result = await _secretManager.GetSecretAsync(secretName, CancellationToken.None);

            // Assert
            Assert.AreEqual(secretValue, result);
        }
        finally
        {
            // Cleanup
            Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", null);
        }
    }

    [TestMethod]
    public async Task GetSecretAsync_WhenKeyVaultDisabled_UsesFallbackDirectly()
    {
        // Arrange
        const string secretName = "TestSecret";
        const string secretValue = "env-only-secret";
        
        _config.Security.EnableKeyVault = false;
        Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", secretValue);
        

        try
        {
            // Act
            var result = await _secretManager.GetSecretAsync(secretName, CancellationToken.None);

            // Assert
            Assert.AreEqual(secretValue, result);
            _mockKeyVaultClient.Verify(x => x.GetSecretAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Never);
        }
        finally
        {
            // Cleanup
            Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", null);
        }
    }

    [TestMethod]
    public async Task GetSecretAsync_WhenNoSecretsFound_ThrowsSecretNotFoundException()
    {
        // Arrange
        const string secretName = "NonExistentSecret";
        
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new RequestFailedException(404, "Secret not found"));
        

        // Act & Assert
        var exception = await Assert.ThrowsExceptionAsync<SecretNotFoundException>(
            () => _secretManager.GetSecretAsync(secretName, CancellationToken.None));
        
        Assert.AreEqual(secretName, exception.SecretName);
        Assert.IsTrue(exception.Message.Contains("Secret not found in any source"));
    }

    [TestMethod]
    public async Task SecretExistsAsync_WhenKeyVaultSecretExists_ReturnsTrue()
    {
        // Arrange
        const string secretName = "ExistingSecret";
        
        var keyVaultSecret = SecretModelFactory.KeyVaultSecret(
            new SecretProperties(secretName), 
            "some-value");
        
        var response = Response.FromValue(keyVaultSecret, Mock.Of<Response>());
        
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()))
            .ReturnsAsync(response);
        

        // Act
        var exists = await _secretManager.SecretExistsAsync(secretName, CancellationToken.None);

        // Assert
        Assert.IsTrue(exists);
    }

    [TestMethod]
    public async Task SecretExistsAsync_WhenKeyVaultSecretNotFoundButEnvExists_ReturnsTrue()
    {
        // Arrange
        const string secretName = "EnvOnlySecret";
        const string secretValue = "env-secret";
        
        Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", secretValue);
        
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new RequestFailedException(404, "Not found"));
        

        try
        {
            // Act
            var exists = await _secretManager.SecretExistsAsync(secretName, CancellationToken.None);

            // Assert
            Assert.IsTrue(exists);
        }
        finally
        {
            // Cleanup
            Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", null);
        }
    }

    [TestMethod]
    public async Task SecretExistsAsync_WhenNoSecretsFound_ReturnsFalse()
    {
        // Arrange
        const string secretName = "NonExistentSecret";
        
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new RequestFailedException(404, "Not found"));
        

        // Act
        var exists = await _secretManager.SecretExistsAsync(secretName, CancellationToken.None);

        // Assert
        Assert.IsFalse(exists);
    }

    [TestMethod]
    public async Task GetSecretsAsync_WithMultipleSecrets_RetrievesConcurrently()
    {
        // Arrange
        var secretNames = new[] { "Secret1", "Secret2", "Secret3" };
        var secretValues = new Dictionary<string, string>
        {
            ["Secret1"] = "value1",
            ["Secret2"] = "value2",
            ["Secret3"] = "value3"
        };

        foreach (var (name, value) in secretValues)
        {
            var keyVaultSecret = SecretModelFactory.KeyVaultSecret(
                new SecretProperties(name), 
                value);
            
            var response = Response.FromValue(keyVaultSecret, Mock.Of<Response>());
            
            _mockKeyVaultClient.Setup(x => x.GetSecretAsync(name, null, It.IsAny<CancellationToken>()))
                .ReturnsAsync(response);
        }
        

        // Act
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        var results = await _secretManager.GetSecretsAsync(secretNames, CancellationToken.None);
        stopwatch.Stop();

        // Assert
        Assert.AreEqual(3, results.Count);
        foreach (var (name, value) in secretValues)
        {
            Assert.IsTrue(results.ContainsKey(name));
            Assert.AreEqual(value, results[name]);
        }
        
        // Verify all secrets were called (concurrent execution)
        foreach (var name in secretNames)
        {
            _mockKeyVaultClient.Verify(x => x.GetSecretAsync(name, null, It.IsAny<CancellationToken>()), Times.Once);
        }
        
        // Concurrent execution should be faster than sequential
        Assert.IsTrue(stopwatch.ElapsedMilliseconds < 1000); // Should be much faster than 3 sequential calls
    }

    [TestMethod]
    public async Task GetSecretsAsync_WithPartialFailures_ReturnsAvailableSecrets()
    {
        // Arrange
        var secretNames = new[] { "SuccessSecret", "FailSecret", "EnvSecret" };
        
        // Setup successful Key Vault secret
        var successSecret = SecretModelFactory.KeyVaultSecret(
            new SecretProperties("SuccessSecret"), 
            "success-value");
        var successResponse = Response.FromValue(successSecret, Mock.Of<Response>());
        
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync("SuccessSecret", null, It.IsAny<CancellationToken>()))
            .ReturnsAsync(successResponse);
        
        // Setup failed Key Vault secret
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync("FailSecret", null, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new RequestFailedException("Access denied"));
        
        // Setup environment fallback
        Environment.SetEnvironmentVariable("AZDO_ENVSECRET", "env-value");
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync("EnvSecret", null, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new RequestFailedException(404, "Not found"));
        

        try
        {
            // Act
            var results = await _secretManager.GetSecretsAsync(secretNames, CancellationToken.None);

            // Assert
            Assert.AreEqual(2, results.Count); // Only successful retrievals
            Assert.IsTrue(results.ContainsKey("SuccessSecret"));
            Assert.AreEqual("success-value", results["SuccessSecret"]);
            Assert.IsTrue(results.ContainsKey("EnvSecret"));
            Assert.AreEqual("env-value", results["EnvSecret"]);
            Assert.IsFalse(results.ContainsKey("FailSecret"));
        }
        finally
        {
            // Cleanup
            Environment.SetEnvironmentVariable("AZDO_ENVSECRET", null);
        }
    }

    [TestMethod]
    public async Task RefreshSecretAsync_UpdatesCachedValue()
    {
        // Arrange
        const string secretName = "RefreshableSecret";
        const string initialValue = "initial-value";
        const string updatedValue = "updated-value";
        
        var initialSecret = SecretModelFactory.KeyVaultSecret(
            new SecretProperties(secretName), 
            initialValue);
        var initialResponse = Response.FromValue(initialSecret, Mock.Of<Response>());
        
        var updatedSecret = SecretModelFactory.KeyVaultSecret(
            new SecretProperties(secretName), 
            updatedValue);
        var updatedResponse = Response.FromValue(updatedSecret, Mock.Of<Response>());
        
        _mockKeyVaultClient.SetupSequence(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()))
            .ReturnsAsync(initialResponse)
            .ReturnsAsync(updatedResponse);
        

        // Act
        var firstResult = await _secretManager.GetSecretAsync(secretName, CancellationToken.None);
        await _secretManager.RefreshSecretsAsync(CancellationToken.None);
        var secondResult = await _secretManager.GetSecretAsync(secretName, CancellationToken.None);

        // Assert
        Assert.AreEqual(initialValue, firstResult);
        Assert.AreEqual(updatedValue, secondResult);
        _mockKeyVaultClient.Verify(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()), Times.Exactly(2));
    }

    [TestMethod]
    public async Task GetSecretAsync_WithCancellation_ThrowsOperationCancelledException()
    {
        // Arrange
        const string secretName = "CancellableSecret";
        using var cts = new CancellationTokenSource();
        cts.Cancel();
        
        _mockKeyVaultClient.Setup(x => x.GetSecretAsync(secretName, null, It.IsAny<CancellationToken>()))
            .ThrowsAsync(new OperationCanceledException());
        

        // Act & Assert
        await Assert.ThrowsExceptionAsync<OperationCanceledException>(
            () => _secretManager.GetSecretAsync(secretName, cts.Token));
    }

    [TestMethod]
    public void Constructor_WithoutKeyVaultClient_DisablesKeyVault()
    {
        // Arrange & Act

        // Assert - should not throw and should fall back to environment variables only
        Assert.IsNotNull(_secretManager);
    }

    [TestMethod]
    public async Task GetSecretAsync_WithEmptySecretName_ThrowsArgumentException()
    {
        // Arrange

        // Act & Assert
        await Assert.ThrowsExceptionAsync<ArgumentException>(
            () => _secretManager.GetSecretAsync("", CancellationToken.None));
        
        await Assert.ThrowsExceptionAsync<ArgumentNullException>(
            () => _secretManager.GetSecretAsync(null!, CancellationToken.None));
    }

    [TestMethod]
    public async Task GetSecretsAsync_WithEmptyArray_ReturnsEmptyDictionary()
    {
        // Arrange

        // Act
        var results = await _secretManager.GetSecretsAsync(Array.Empty<string>(), CancellationToken.None);

        // Assert
        Assert.IsNotNull(results);
        Assert.AreEqual(0, results.Count);
    }

    [TestMethod]
    public async Task GetSecretsAsync_UsesModernCollectionExpressions()
    {
        // Arrange
        var secretNames = new[] { "Secret1", "Secret2" };
        var secretValues = FrozenDictionary.ToFrozenDictionary(new Dictionary<string, string>
        {
            ["Secret1"] = "value1",
            ["Secret2"] = "value2"
        });

        foreach (var (name, value) in secretValues)
        {
            var keyVaultSecret = SecretModelFactory.KeyVaultSecret(
                new SecretProperties(name), 
                value);
            
            var response = Response.FromValue(keyVaultSecret, Mock.Of<Response>());
            
            _mockKeyVaultClient.Setup(x => x.GetSecretAsync(name, null, It.IsAny<CancellationToken>()))
                .ReturnsAsync(response);
        }
        

        // Act
        var results = await _secretManager.GetSecretsAsync(secretNames, CancellationToken.None);

        // Assert
        Assert.AreEqual(2, results.Count);
        Assert.IsTrue(secretValues.All(kvp => results.ContainsKey(kvp.Key) && results[kvp.Key] == kvp.Value));
    }
}

[TestClass]
public class SecretNotFoundExceptionTests
{
    [TestMethod]
    public void Constructor_WithSecretNameAndMessage_SetsProperties()
    {
        // Arrange
        const string secretName = "TestSecret";
        const string message = "Test message";

        // Act
        var exception = new SecretNotFoundException(secretName, message);

        // Assert
        Assert.AreEqual(secretName, exception.SecretName);
        Assert.AreEqual(message, exception.Message);
    }

    [TestMethod]
    public void Constructor_WithSecretNameMessageAndInnerException_SetsProperties()
    {
        // Arrange
        const string secretName = "TestSecret";
        const string message = "Test message";
        var innerException = new InvalidOperationException("Inner exception");

        // Act
        var exception = new SecretNotFoundException(secretName, message, innerException);

        // Assert
        Assert.AreEqual(secretName, exception.SecretName);
        Assert.AreEqual(message, exception.Message);
        Assert.AreEqual(innerException, exception.InnerException);
    }

    [TestMethod]
    public void ToString_IncludesSecretName()
    {
        // Arrange
        const string secretName = "TestSecret";
        const string message = "Test message";
        var exception = new SecretNotFoundException(secretName, message);

        // Act
        var result = exception.ToString();

        // Assert
        Assert.IsTrue(result.Contains(secretName));
        Assert.IsTrue(result.Contains(message));
        Assert.IsTrue(result.Contains(nameof(SecretNotFoundException)));
    }

    [TestMethod]
    public async Task GetSecretAsync_WithEnvironmentVariable_ReturnsCorrectValue()
    {
        // Arrange
        const string secretName = "TestEnvironmentSecret";
        const string secretValue = "test-env-value-123";
        
        var localConfig = new ProductionConfiguration
        {
            Security = new ProductionSecurityConfiguration
            {
                EnableKeyVault = false // Disable Key Vault to test env var fallback
            }
        };
        
        var localOptions = new Mock<IOptions<ProductionConfiguration>>();
        localOptions.Setup(x => x.Value).Returns(localConfig);
        var localSecretManager = new ProductionSecretManager(_mockLogger.Object, localOptions.Object);
        
        Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", secretValue);

        try
        {
            // Act
            var result = await localSecretManager.GetSecretAsync(secretName, CancellationToken.None);

            // Assert
            Assert.AreEqual(secretValue, result);
        }
        finally
        {
            Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", null);
            localSecretManager.Dispose();
        }
    }

    [TestMethod]
    public async Task GetSecretAsync_WithAlternativeEnvironmentVariable_ReturnsCorrectValue()
    {
        // Arrange
        const string secretName = "test-alt-secret";
        const string secretValue = "alt-env-value-456";
        
        var localConfig = new ProductionConfiguration
        {
            Security = new ProductionSecurityConfiguration
            {
                EnableKeyVault = false
            }
        };
        
        var localOptions = new Mock<IOptions<ProductionConfiguration>>();
        localOptions.Setup(x => x.Value).Returns(localConfig);
        var localSecretManager = new ProductionSecretManager(_mockLogger.Object, localOptions.Object);
        
        // Use alternative naming (with underscores)
        Environment.SetEnvironmentVariable(secretName.ToUpperInvariant().Replace("-", "_"), secretValue);

        try
        {
            // Act
            var result = await localSecretManager.GetSecretAsync(secretName, CancellationToken.None);

            // Assert
            Assert.AreEqual(secretValue, result);
        }
        finally
        {
            Environment.SetEnvironmentVariable(secretName.ToUpperInvariant().Replace("-", "_"), null);
            localSecretManager.Dispose();
        }
    }

    [TestMethod]
    public async Task GetSecretAsync_WithNonExistentSecret_ThrowsSecretNotFoundException()
    {
        // Arrange
        const string secretName = "NonExistentSecret";
        _config.Security.EnableKeyVault = false;

        // Act & Assert
        var exception = await Assert.ThrowsExceptionAsync<SecretNotFoundException>(
            () => _secretManager.GetSecretAsync(secretName, CancellationToken.None));
        
        Assert.AreEqual(secretName, exception.SecretName);
        Assert.IsTrue(exception.Message.Contains(secretName));
    }

    [TestMethod]
    public async Task SecretExistsAsync_WithExistingSecret_ReturnsTrue()
    {
        // Arrange
        const string secretName = "ExistingSecret";
        const string secretValue = "existing-value";
        
        _config.Security.EnableKeyVault = false;
        Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", secretValue);

        try
        {
            // Act
            var exists = await _secretManager.SecretExistsAsync(secretName, CancellationToken.None);

            // Assert
            Assert.IsTrue(exists);
        }
        finally
        {
            Environment.SetEnvironmentVariable($"AZDO_{secretName.ToUpperInvariant()}", null);
        }
    }

    [TestMethod]
    public async Task SecretExistsAsync_WithNonExistentSecret_ReturnsFalse()
    {
        // Arrange
        const string secretName = "NonExistentSecretCheck";
        _config.Security.EnableKeyVault = false;

        // Act
        var exists = await _secretManager.SecretExistsAsync(secretName, CancellationToken.None);

        // Assert
        Assert.IsFalse(exists);
    }

    [TestMethod]
    public async Task GetSecretsAsync_WithMultipleSecrets_ReturnsAllValues()
    {
        // Arrange
        var secretData = new Dictionary<string, string>
        {
            ["Secret1"] = "value1",
            ["Secret2"] = "value2",
            ["Secret3"] = "value3"
        };
        
        _config.Security.EnableKeyVault = false;
        
        // Set up environment variables
        foreach (var kvp in secretData)
        {
            Environment.SetEnvironmentVariable($"AZDO_{kvp.Key.ToUpperInvariant()}", kvp.Value);
        }
        

        try
        {
            // Act
            var results = await _secretManager.GetSecretsAsync(secretData.Keys, CancellationToken.None);

            // Assert
            Assert.AreEqual(secretData.Count, results.Count);
            foreach (var kvp in secretData)
            {
                Assert.IsTrue(results.ContainsKey(kvp.Key));
                Assert.AreEqual(kvp.Value, results[kvp.Key]);
            }
        }
        finally
        {
            // Cleanup
            foreach (var key in secretData.Keys)
            {
                Environment.SetEnvironmentVariable($"AZDO_{key.ToUpperInvariant()}", null);
            }
        }
    }

    [TestMethod]
    public async Task ValidateRequiredSecretsAsync_WithAllSecretsPresent_DoesNotThrow()
    {
        // Arrange
        var requiredSecrets = new[] { "RequiredSecret1", "RequiredSecret2" };
        
        _config.Security.EnableKeyVault = false;
        
        foreach (var secret in requiredSecrets)
        {
            Environment.SetEnvironmentVariable($"AZDO_{secret.ToUpperInvariant()}", "test-value");
        }
        

        try
        {
            // Act & Assert - Should not throw
            await _secretManager.ValidateRequiredSecretsAsync(requiredSecrets, CancellationToken.None);
        }
        finally
        {
            // Cleanup
            foreach (var secret in requiredSecrets)
            {
                Environment.SetEnvironmentVariable($"AZDO_{secret.ToUpperInvariant()}", null);
            }
        }
    }

    [TestMethod]
    public async Task ValidateRequiredSecretsAsync_WithMissingSecret_ThrowsValidationException()
    {
        // Arrange
        var requiredSecrets = new[] { "PresentSecret", "MissingSecret" };
        
        _config.Security.EnableKeyVault = false;
        Environment.SetEnvironmentVariable($"AZDO_PRESENTSECRET", "test-value");
        // Don't set MissingSecret
        

        try
        {
            // Act & Assert
            await Assert.ThrowsExceptionAsync<SecretValidationException>(
                () => _secretManager.ValidateRequiredSecretsAsync(requiredSecrets, CancellationToken.None));
        }
        finally
        {
            Environment.SetEnvironmentVariable($"AZDO_PRESENTSECRET", null);
        }
    }
}